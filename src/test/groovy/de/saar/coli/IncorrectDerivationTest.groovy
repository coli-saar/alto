package de.saar.coli

import de.saar.basic.Pair
import de.up.ling.irtg.Interpretation
import de.up.ling.irtg.InterpretedTreeAutomaton
import de.up.ling.irtg.algebra.ParserException
import de.up.ling.irtg.algebra.SetAlgebra
import de.up.ling.irtg.algebra.SubsetAlgebra
import de.up.ling.irtg.automata.Intersectable
import de.up.ling.irtg.automata.TreeAutomaton
import de.up.ling.irtg.util.FirstOrderModel
import de.up.ling.tree.Tree;
import org.junit.Test;
import static org.junit.Assert.*

/**
 * Author: Arne Köhn
 */

public class IncorrectDerivationTest {
    @Test
    public void testViterbiCaching() {
        String FEATURES = "color+type+x1+x2+y1+y2+z1+z2+to+from+height+width+length+orientation"
        InterpretedTreeAutomaton irtg = InterpretedTreeAutomaton.fromString(grammar)
        Interpretation<Set<List<String>>> refI = (Interpretation<Set<List<String>>>) irtg.getInterpretation("ref");
        SetAlgebra refA = (SetAlgebra) refI.getAlgebra();
        refA.setModel(FirstOrderModel.read(new StringReader(model)))
        Interpretation<BitSet> semI = (Interpretation<BitSet>) irtg.getInterpretation("sem");
        SubsetAlgebra semA = (SubsetAlgebra) semI.getAlgebra();
        semA.readOptions(new StringReader(FEATURES));
        
        Set<BitSet> semInputs = semInput.split(",").collect {x ->
            try {
                return semA.parseString(x);
            } catch (ParserException e) {
                // convert checked to unchecked exception to make map work
                throw new RuntimeException(e);
            }
        }

        def ta = semA.decompose(semInputs);
        def semO = semI.invhom(ta);

        TreeAutomaton<String> automaton = irtg.getAutomaton();
        Intersectable<Set<List<String>>> refO = refI.parse(refA.parseString(refInput))

        //TreeAutomaton<Pair<Pair<String, Set<List<String>>>, BitSet>> ta =
        def auto = automaton.intersect(refO).intersect(semO);

        // these two tests are not important for the problem and therefore not translated to groovy (but they
        // do not fail in the java version)
        // This is the intended derivation
        // assertTrue(isDerivable(List.of("a", "row",  "in front of",  "the", "previous", "row"), auto));
        // and this is the one generated by the automaton
        // assertTrue(isDerivable(List.of("a", "row",  "to the right", "of length four", "in front of", "the", "previous", "row"), auto));

        def bestTree = auto.viterbi()
        def concreteAuto = auto.asConcreteTreeAutomaton()
        def bestTreeConcrete = concreteAuto.viterbi()
        assert(concreteAuto.getWeight(bestTreeConcrete) > 0.35)
        assert(auto.getWeight(bestTree) > 0.35)
    }

    public boolean isDerivable(List<String> instruction, TreeAutomaton<String> automaton) {
        Intersectable<List<String>> invhom = strI.parse(instruction);
        var sta = strI.getAlgebra().decompose(instruction);
        var ta = automaton.intersect(invhom);
        def result = ta.languageIterable().iterator().hasNext()
        if (result == false) {
            return false
        }
        ta.analyze();
        for (Tree<String> tree: ta.languageIterable()) {
            System.out.println(semA.representAsString(semI.interpret(tree)));
            System.out.println(refA.representAsString(refI.interpret(tree)));
            System.out.println("weight: " + ta.getWeight(tree));
        }
        return true;
    }

	String refInput = "{row20-1-2-3-1-2}"
	String semInput = "type+x1+y1+z1+length+orientation,type+x1+x2+y1+z1+z2,type+x2+y2+z2+length+orientation"
    String model = """
{
  "orientleftright": [
    [
      "row20-1-2-3-1-2"
    ],
    [
      "row10-1-3-3-1-3"
    ]
  ],
  "length4": [
    [
      "row20-1-2-3-1-2"
    ],
    [
      "row10-1-3-3-1-3"
    ]
  ],
  "row": [
    [
      "row20-1-2-3-1-2"
    ],
    [
      "row10-1-3-3-1-3"
    ]
  ],
  "it": [
    [
      "row10-1-3-3-1-3"
    ]
  ],
  "in-front-of": [
    [
      "row20-1-2-3-1-2",
      "row10-1-3-3-1-3"
    ]
  ],
  "target": [
    [
      "row20-1-2-3-1-2"
    ]
  ]
}
"""
    String grammar = """
interpretation string: de.up.ling.irtg.algebra.StringAlgebra
interpretation ref: de.up.ling.irtg.algebra.SetAlgebra
interpretation sem: de.up.ling.irtg.algebra.SubsetAlgebra

// a referent is always the location the current subtree refers to
// Terminalsymbole dürfen nur in einer einzigen Regel auftreten

// Refers to the wall if all indefPPs also refer to the indefinite
// wall and nothing else.
// (size_1(?1)) -> all PPs refer to the same thing
// intersect_1 -> this thing is the indefwall


// NPs
////////////////////////////////////////////////////////////////////////
IndefNP! -> np(N) [0.9]
  [string] *("a", ?1)
  [ref] ?1
  [sem] ?1

DefNP -> dnp(N)  [0.9]
  [string] *("the", ?1)
  [ref] size_1(?1)
  [sem] ?1


// objects
////////////////////////////////////////////////////////////////////////
N -> obj(Obj) [0.9]
  [string] ?1
  [ref] ?1
  [sem] ?1

Obj -> bridge [0.9]
  [string] "bridge"
  [ref] bridge
  [sem] type

Obj -> wall [0.9]
  [string] "wall"
  [ref] wall
  [sem] type

Obj -> row [0.9]
  [string] "row"
  [ref] row
  [sem] type

Obj -> railing [0.9]
  [string] "railing"
  [ref] railing
  [sem] type

Obj -> block [0.9]
  [string] "block"
  [ref] block
  [sem] type

Obj -> floor [0.9]
  [string] "floor"
  [ref] floor
  [sem] type


// locations
////////////////////////////////////////////////////////////////////////
LocP -> top(DefNP) [0.9]
  [string] *("on top of", ?1)
  [ref] project_1(intersect_2(top-of,?1))
  [sem] x1+y1+z1+x2+y2+z2

LocP -> below(DefNP) [0.9]
  [string] *("below of", ?1)
  [ref] project_2(intersect_1(top-of,?1))
  [sem] x1+y1+z1+x2+y2+z2
  
LocP -> left(DefNP) [0.9]
  [string] *("to the left of", ?1)
  [ref] project_1(intersect_2(left-of,?1))
  [sem] x1+y1+z1+x2+y2+z2
  
LocP -> right(DefNP) [0.9]
  [string] *("to the right of", ?1)
  [ref] project_2(intersect_1(left-of,?1))
  [sem] x1+y1+z1+x2+y2+z2
  
LocP -> front(DefNP) [0.9]
  [string] *("in front of", ?1)
  [ref] project_1(intersect_2(in-front-of,?1))
  [sem] x1+y1+z1+x2+y2+z2
  
LocP -> behind(DefNP) [0.9]
  [string] *("behind", ?1)
  [ref] project_2(intersect_1(in-front-of,?1))
  [sem] x1+y1+z1+x2+y2+z2


// Single addressable blocks of larger objects

// diff(?1, target): We cannot explain the location of a block
// using the target object we want to describe because the user
// does not know the shape of the target object yet.
// therefore, we remove the target object.

N -> frontleftcorner(DefNP) [0.9]
  [string] *("front left corner of", ?1)
  [ref] intersect(block, project_2(intersect_1(from, diff(?1, target))))
  [sem] x1+y1+z1+x2+y2+z2

N -> backtleftcorner(DefNP) [0.9]
  [string] *("back left corner of", ?1)
  [ref] intersect(block, project_2(intersect_1(fromaway, diff(?1, target))))
  [sem] x1+y1+z1+x2+y2+z2

N -> frontrightcorner(DefNP) [0.9]
  [string] *("front right corner of", ?1)
  [ref] intersect(block, project_2(intersect_1(tohere, diff(?1, target))))
  [sem] x1+y1+z1+x2+y2+z2

N -> backrightcorner(DefNP) [0.9]
  [string] *("back right corner of", ?1)
  [ref] intersect(block, project_2(intersect_1(to, diff(?1, target))))
  [sem] x1+y1+z1+x2+y2+z2


// relations
////////////////////////////////////////////////////////////////////////

N -> from(N, DefNP) [0.9]
  [string] *(?1, *("from", ?2))
  [ref] intersect(project_1(intersect_2(from, ?2)), ?1)
  [sem] union(?1, x1+y1+z1)

N -> fromaway(N, DefNP) [0.9]
  [string] *(?1, *("from", ?2))
  [ref] intersect(project_1(intersect_2(fromaway, ?2)), ?1)
  [sem] union(?1, x1+y1+z2)

N -> fromtopof(N, DefNP) [0.9]
  [string] *(?1, *("from the top of", ?2))
  [ref] intersect(project_1(intersect_2(fromtopof, ?2)), ?1)
  [sem] union(?1, x1+y1+z1)

N -> to(N, DefNP) [0.9]
  [string] *(?1, *("to", ?2))
  [ref] intersect(project_1(intersect_2(to,?2)), ?1)
  [sem] union(?1, x2+y2+z2)

// This rule is valid but might be confusing in some cases
// e.g. "build a wall from the blue block to the top of the
// black block" -- make the score a bit worse to disprefer
// it against slightly longer other options
N -> totopof(N, DefNP) [0.7]
   [string] *(?1, *("to the top of", ?2))
   [ref] intersect(project_1(intersect_2(totopof,?2)), ?1)
   [sem] union(?1, x2+y2+z2)

N -> tobottom(N, DefNP) [0.9]
  [string] *(?1, *("to", ?2))
  [ref] intersect(project_1(intersect_2(tobottom,?2)), ?1)
  [sem] union(?1, x2+y1+z2)

N -> tohere(N, DefNP) [0.9]
  [string] *(?1, *("to", ?2))
  [ref] intersect(project_1(intersect_2(tohere,?2)), ?1)
  [sem] union(?1, x2+y2+z1)


// on the other side of the bridge
N -> othersideof(N, DefNP) [0.9]
  [string] *(?1, *("on the other side of", ?2))
  [ref] intersect(?1, project_1(intersect_3(intersect_2(otherside, ?2), it)))
  [sem] union(?1, x1+y1+z1+x2+y2+z2)

N -> otherside(N) [0.3]
  [string] *(?1, "on the other side")
  [ref] intersect(?1, size_1(project_1(intersect_3(otherside, it))))
  [sem] union(?1, x1+y1+z1+x2+y2+z2)

// Use a location as additional description
N -> loc(N,LocP) [0.9]
  [string] *(?1, ?2)
  [ref] intersect(?1,?2)
  [sem] union(?1, ?2)

N -> height2(N) [0.9]
  [string] *(?1, "of height two")
  [ref] intersect(height2, ?1)
  [sem] union(height, ?1)
// /* see https://github.com/coli-saar/alto/issues/62
N -> height3(N) [0.9]
  [string] *(?1, "of height three")
  [ref] intersect(height3, ?1)
  [sem] union(height, ?1)

N -> height4(N) [0.9]
  [string] *(?1, "of height four")
  [ref] intersect(height4, ?1)
  [sem] union(height, ?1)
// */
N -> length2(N) [0.9]
  [string] *(?1, "of length two")
  [ref] intersect(length2, ?1)
  [sem] union(length, ?1)

N -> length3(N) [0.9]
  [string] *(?1, "of length three")
  [ref] intersect(length3, ?1)
  [sem] union(length, ?1)

N -> length4(N) [0.9]
  [string] *(?1, "of length four")
  [ref] intersect(length4, ?1)
  [sem] union(length, ?1)

N -> toright(N) [0.9]
  [string] *(?1, "to the right")
  [ref] intersect(orientleftright, ?1)
  [sem] union(orientation, ?1)

N -> orientaway(N) [0.9]
  [string] *(?1, "away from you")
  [ref] intersect(orientaway, ?1)
  [sem] union(orientation, ?1)

// adjectives
////////////////////////////////////////////////////////////////////////
Obj -> orange(Obj) [0.9]
  [string] *("orange", ?1)
  [ref] intersect(orange, ?1)
  [sem] dunion(color, ?1)

Obj -> yellow(Obj) [0.9]
  [string] *("yellow", ?1)
  [ref] intersect(yellow, ?1)
  [sem] dunion(color, ?1)

Obj -> blue(Obj) [0.9]
  [string] *("blue", ?1)
  [ref] intersect(blue, ?1)
  [sem] dunion(color, ?1)

Obj -> green(Obj) [0.9]
  [string] *("green", ?1)
  [ref] intersect(green, ?1)
  [sem] dunion(color, ?1)

Obj -> red(Obj) [0.9]
  [string] *("red", ?1)
  [ref] intersect(red, ?1)
  [sem] dunion(color, ?1)

Obj -> redw(Obj) [0.9]
  [string] *("red", ?1)
  [ref] intersect(red_wool, ?1)
  [sem] dunion(color, ?1)

Obj -> bluew(Obj) [0.9]
  [string] *("blue", ?1)
  [ref] intersect(blue_wool, ?1)
  [sem] dunion(color, ?1)

Obj -> yelloww(Obj) [0.9]
  [string] *("yellow", ?1)
  [ref] intersect(yellow_wool, ?1)
  [sem] dunion(color, ?1)

Obj -> blackw(Obj) [0.9]
  [string] *("black", ?1)
  [ref] intersect(black_wool, ?1)
  [sem] dunion(color, ?1)

Obj -> orangew(Obj) [0.9]
  [string] *("orange", ?1)
  [ref] intersect(orange_wool, ?1)
  [sem] dunion(color, ?1)


// TODO: what is the sem interpretation for this??
// probably not important because this rule can only be used
// to describe definite objects and the sem does not propagate to
// indefinite descriptions
Obj -> prev(Obj) [0.9]
  [string] *("previous", ?1)
  [ref] intersect(it, ?1)
  [sem] dunion(x1+y1+z1+color, ?1)

/*
IndefPP -> indefHeight(IndefPP) [0.9]
  [string] *("of height three", ?1)
  [ref] intersect(heightthree, ?1)
  [sem] union(height, ?1)

IndefPP -> widthThree(IndefPP) [0.9]
  [string] *("of length three", ?1)
  [ref] intersect(widththree, ?1)
  [sem] union(width, ?1)

IndefPP -> depthThree(IndefPP) [0.9]
  [string] *("of length three", ?1)
  [ref] intersect(depththree, ?1)
  [sem] union(depth, ?1)


IndefPP -> indefSameShapeIt(IndefPP) [0.9]
  [string] *("of the same shape as the previous one", ?1)
  [ref] intersect(project_1(intersect_2(sameshape, it)), ?1)
  [sem] union(shape, ?1)
*/

"""
}
